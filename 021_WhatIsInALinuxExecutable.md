```
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
---------+---------+---------+---------+---------X---------+---------+---------+---------+---------X
$Lastupdate: 2021/11/01 11:16:18 $ T.AIHANA
```
* [目次](/README.md#目次)

---

* [What's in a Linux executable?](https://fasterthanli.me/series/making-our-own-executable-packer/part-1)

---

# 1. Linux の実行可能なファイルには何が含まれているのか？

子供の頃に Linux の実行可能なファイル（*Executables*）が「ただのファイル」であることに気づいて以来、これら実行可能なファイルが私の興味の対象になりました。
拡張子の `.exe` を別のものに変更すれば、NotoPad で開くことができるんです！
さらに別のファイルの拡張子を `.exe` に変更すると「ごもっともな」エラーダイアログが表示されます。

あきらかに、これらのファイルには何か違いがありました。
NotePad で表示されたものはちんぷんかんぷんなものでしたが、そんな「カオス」な状態の中でもなんらかの「秩序（決まりごと）」があるはずです。
12歳の私はそれを知っていましたが、そのすべて理解するためにどこでどのようにして調べていけばよいのかわかりませんでした。

そのため、ここにある一連の記事は過去の私に捧げたいと思います。
その中で Linux の実行可能なファイルはどのような仕組みになっていて、どのように実行され、そしてリンクして圧縮した直後の実行可能なファイルを取り出すプログラムを作る方法について学んでいこうと思います。
それらはすべて実現可能な話です。

前回の記事「[Making our own ping](https://fasterthanli.me/series/making-our-own-ping/part-10)」は全て Microsoft Windows の話だったので、今回は 64-ビットの Linux に焦点を当てることにします。


## でもまず初めに、アセンブリを書かせて下さい

この一連の記事を通して確かなことは、私達が独自の ELF ファイルを発表したいと思っていることですが、以前に取り組んだ Ethernet や IPv4、そして ICMP の時と同様に、まず十分に理解して、完全に動作する Linux の実行可能なファイルを作り、それを色々と細かく「突っ込んでいく」ことにします。


---

#### Cool bear の Hot なヒント

ELF とは *Executable and Linkable Format* の略です。
1983 年に SysV4 の一部として初めて公開され、その後に新しいセクションがいくつか追加されましたが、現在も Linux で使用されている仕様の一つです。

---

まず私は「[Reading files the hard way - Part 2](https://fasterthanli.me/blog/2019/reading-files-the-hard-way-2/)」に戻り NASM 上を使って軽く復習する必要が有りました（貴方がそうしなくても私には貴方を責める権利はありませんが）。

いずれにせよ、ここに簡単な例を用意しました：
これは標準出力に "hi there" を出力して改行するコードです：

```asm
        ; in `hello.asm`

        global _start

        section .text

_start: mov rdi, 1     ; stdout fd
        mov rsi, msg
        mov rdx, 9     ; ８文字＋改行
        mov rax, 1     ; write システムコール
        syscall

        xor rdi, rdi   ; 返り値は ０
        mov rax, 60    ; exit システムコール
        syscall

        section .data

msg:    db "hi there", 10
```

システムコールについては「[Filippo's Searchable Linux Syscall Table](https://filippo.io/linux-syscall-table/)」がとても参考になりました。

これをビルドしてリンクします：

```shell
$ nasm -f elf64 hello.asm
$ ld hello.o -o hello
$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
$ ./hello
hi there
```

いい感じです！

今、この実行可能なファイルのサイズはおよそ 8.68 KiB です。
`gzip -9` を使うと簡単に 372 B まで小さくすることができますが、正直なところ、その中身はどんなものが含まれているのか気になるところです。


---

#### Cool bear の Hot なヒント

これは「純粋な」好奇心であり、「おいおい、なんでそうなるの？」といった好奇心ではありません。

ここは、すべてが一枚のフロッピーディスクに収まっていた「古き良き時代」を思い出して悲しみにしたる場ではありません。
そして、現代のソフトウェアがいかにして肥大化し動きが遅くなったのかを探る場でもありません。
さらに、開発者が「怠け者」であり「誰かが試してみれさえすれば、それほど難しいものでない」という話題に脱線するつもりもありません。

私達はここで何か実用的なもの開発しているのではなく、ただ純粋に学習のために課題を取り上げているのです。

そうではなく貴方がどっぷりとノスタルジアにしたりたいと思っているのであれば、どうぞご自由に "*gestures vaguely at almost all of the internet*" を調べてみて下さい。

---

`hello` の 16進数形式のダンプを出力してみると、先頭あたりに `ELF` の文字が出現し、そのあとにバイナリ・データのかたまりが続きます：

```shell
$ xxd < hello | head
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0200 3e00 0100 0000 b000 4000 0000 0000  ..>.......@.....
00000020: 4000 0000 0000 0000 1002 0000 0000 0000  @...............
00000030: 0000 0000 4000 3800 0200 4000 0600 0500  ....@.8...@.....
00000040: 0100 0000 0500 0000 0000 0000 0000 0000  ................
00000050: 0000 4000 0000 0000 0000 4000 0000 0000  ..@.......@.....
00000060: d500 0000 0000 0000 d500 0000 0000 0000  ................
00000070: 0000 2000 0000 0000 0100 0000 0600 0000  .. .............
00000080: d800 0000 0000 0000 d800 6000 0000 0000  ..........`.....
00000090: d800 6000 0000 0000 0900 0000 0000 0000  ..`.............
```

でも、すぐにその中身のほとんどが null（ゼロ）バイトで埋め尽くされているのがわかります：

```shell
$ xxd < hello | tail -60  | tail
000002f0: d800 0000 0000 0000 0400 0000 0500 0000  ................
00000300: 0800 0000 0000 0000 1800 0000 0000 0000  ................
00000310: 0900 0000 0300 0000 0000 0000 0000 0000  ................
00000320: 0000 0000 0000 0000 c001 0000 0000 0000  ................
00000330: 2700 0000 0000 0000 0000 0000 0000 0000  '...............
00000340: 0100 0000 0000 0000 0000 0000 0000 0000  ................
00000350: 1100 0000 0300 0000 0000 0000 0000 0000  ................
00000360: 0000 0000 0000 0000 e701 0000 0000 0000  ................
00000370: 2700 0000 0000 0000 0000 0000 0000 0000  '...............
00000380: 0100 0000 0000 0000 0000 0000 0000 0000  ................
```

さらにいろいろな名前のかたまりを含む一個の「セクション」があります。これらは何か意味のあるものなのでしょうか？

```shell
$ xxd < hello | tail -32  | head
00000190: 1b00 0000 1000 0200 e100 6000 0000 0000  ..........`.....
000001a0: 0000 0000 0000 0000 2200 0000 1000 0200  ........".......
000001b0: e800 6000 0000 0000 0000 0000 0000 0000  ..`.............
000001c0: 0068 656c 6c6f 2e61 736d 006d 7367 005f  .hello.asm.msg._
000001d0: 5f62 7373 5f73 7461 7274 005f 6564 6174  _bss_start._edat
000001e0: 6100 5f65 6e64 0000 2e73 796d 7461 6200  a._end...symtab.
000001f0: 2e73 7472 7461 6200 2e73 6873 7472 7461  .strtab..shstrta
00000200: 6200 2e74 6578 7400 2e64 6174 6100 0000  b..text..data...
00000210: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000220: 0000 0000 0000 0000 0000 0000 0000 0000  ................
```

さて、この ELF ファイルを使い慣れた端末からいろいろ調べることができるツールがたくさんあります。
はい、そうです。
かなり充実しています。
見渡す限りツールだらけです。
ただし今日は使えません。
今日ではないです。皆さん。

今日は、自分たちの手で解析してみることにします。
[Making our own ping](https://fasterthanli.me/series/making-our-own-ping/part-1)（「自分で専用の ping コマンドを作る」）で使用した `nom` なる「木箱」を使い、あらゆるものを解析できるように準備しました。
[PSD だって](https://github.com/gco/xee/blob/4fa3a6d609dd72b8493e52a68f316f7a02903276/XeePhotoshopLoader.m#L108-L136)。

ただし、それをするにはいくつかの助言が必要です。
[Wikipedia にある ELF についての解説](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)は悪くありませんが、素晴らしい内容ではありません。
本投稿を通して都合よく忘れることにした 32-bit の ELF 関連に惑わされる内容が一部に含まれているからです。

---

#### Cool bear の Hot なヒント

これは、つまり[以前 Canonical 社で揉めていた件](https://www.phoronix.com/scan.php?page=news_item&px=Ubuntu-i386-Dropping-Discussion) と同じです。

---

ということで、64-bit の ELF ファイルのヘッダを見てみることにします：

* FIXME（ELF64 File Header の図）

理解することがたくさんあるのは分かっています。
それらの多くは未だ理解しきれていません！

コードを書き始める前に、基本的な内容を手作業で調べてみることにしましょう。
上の図によると、ファイルのオフセット `62` には「セクション名がついたエントリの番号（*Index of entry with section names*）」があります。
先に作った `hello` プログラムの場合だと...

```shell
# -s オプションは指定したバイトに移動（シーク）、-l オプションはサイズ
$ xxd -s 62 -l 2 ./hello
0000003e: 0500                                     ..
```

`05` と `00` のバイト列は（この例ではリトルエンディアンのファイルを見ているので）正確には `0x0050` です。つまり `5` です。
そのためテーブルの中で５番目にある「セクション」のヘッダにそのセクションの名前があるということになります。

この時点で「セクション」が何なのか分かっていませんが、ファイルは複数のセクションに分割され、セクションの開始とサイズがそのセクションのヘッダの中に格納されているとみて間違いはないでしょう。

セクションのヘッダを要素とするテーブルは：

```shell
# -g オプションはグループのサイズ、-e オプションはリトルエンディアン
$ xxd -s 40 -l 8 -g 8 -e ./hello
00000028: 0000000000000210                   ........
```

この `0x0210` は：

```shell
$ echo $((0x0210))
528
```

---

#### Cool bear の Hot なヒント

そもそも `xxd` コマンドが16進数表記をサポートしていないのですが、`$((expr))` を使った[シェルの算術式](https://www.tldp.org/LDP/abs/html/arithexp.html)で変換しておくことは可能です。

---

[Wikipedia にある ELF についての解説](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#Section_header)によれば、すべてのセクションのヘッダにはファイル内のオフセット（場所）が記録されており、この位置にセクションのデータが格納されているようで、そのオフセットは `0x18` とのことです。

そしてセクションのヘッダ・サイズはすべて `0x40` です。
ここでは５番目のセクションがほしいので：

```shell
$ xxd -s $((0x0210 + 0x40 * 5 + 0x18)) -l 8 -g 8 -e ./hello
00000368: 00000000000001e7                   ........
```

となりセクション名を含むセクションのデータはオフセット `0x01e7` にあるということになります。
では確認してみましょう：

```shell
xxd -s $((0x01e7)) ./hello | head -4
000001e7: 002e 7379 6d74 6162 002e 7374 7274 6162  ..symtab..strtab
000001f7: 002e 7368 7374 7274 6162 002e 7465 7874  ..shstrtab..text
00000207: 002e 6461 7461 0000 0000 0000 0000 0000  ..data..........
00000217: 0000 0000 0000 0000 0000 0000 0000 0000  ................
```

これらは、はじめの方で `hello` をダンプしたときに見かけた文字列ですね！

